<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LWFL Live Dashboard</title>
<style>
  :root{
    --bg:#f7f8fb; --card:#fff; --ink:#111827; --muted:#6b7280;
    --brand:#4f46e5; --brand2:#06b6d4; --good:#059669; --bad:#dc2626;
    --ring: rgba(79,70,229,.25);
    --fs: 14px;
    --content-max: 1200px; /* header/pillnav match standings width */
  }

  /* Base */
  * { box-sizing: border-box; }
  html { font-size: var(--fs); }
  body {
    margin: 0; padding: 0;
    background: var(--bg); color: var(--ink);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    -webkit-text-size-adjust: 100%;
    text-size-adjust: 100%;
  }
  img, svg, canvas, video { max-width: 100%; height: auto; }
  .wrap { max-width: var(--content-max); margin: 36px auto; padding: 0 16px; }

  /* Title card */
  .titlecard{
    background: linear-gradient(135deg,var(--brand),var(--brand2));
    color:#fff; border-radius:18px; padding:28px;
    box-shadow:0 10px 30px rgba(0,0,0,.12)
  }
  .titlecard h1{ margin:0 0 6px; font-size:32px }
  .muted{ color:#e5e7eb }
  .badge{
    display:inline-block; background:#eef2ff; color:#3730a3;
    border-radius:999px; padding:4px 10px; font-weight:700; font-size:12px; margin-left:8px
  }

  /* Polished control bar */
  .controlbar{
    display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:14px;
  }
  @media (max-width: 720px){ .controlbar{ grid-template-columns:1fr; } }
  .field{
    background: rgba(255,255,255,.92);
    border:1px solid #e5e7eb; border-radius:14px; padding:10px 12px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.65), 0 2px 8px rgba(0,0,0,.06);
  }
  .label{
    font-size:11px; text-transform:uppercase; letter-spacing:.04em;
    color:#475569; font-weight:700; margin-bottom:6px;
  }
  .input-row{ display:flex; align-items:center; flex-wrap:wrap; gap:10px; }
  .select-wrap{
    background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:6px 10px;
    box-shadow:0 1px 3px rgba(0,0,0,.04);
  }
  .select-wrap select{ border:none; outline:none; background:transparent; font-size:16px; }
  .inline-note{ color:#6b7280; font-size:12px; }
  .btn.ghost{
    background:#fff; border:1px solid #dbe1f1; border-radius:10px; padding:8px 12px;
    box-shadow:0 1px 3px rgba(0,0,0,.06); color:#2563eb; font-weight:600; cursor:pointer;
  }
  .btn.ghost:hover{ background:#f5f7ff; }
  .switch2{ display:inline-flex; align-items:center; gap:8px; -webkit-tap-highlight-color:transparent; }
  .switch2 input{
    appearance:none; width:42px; height:24px; border-radius:999px; background:#e5e7eb;
    position:relative; outline:none; cursor:pointer; transition:background .2s ease;
    box-shadow:inset 0 0 0 1px rgba(0,0,0,.04);
  }
  .switch2 input::after{
    content:""; position:absolute; top:3px; left:3px; width:18px; height:18px; border-radius:50%;
    background:#fff; box-shadow:0 1px 2px rgba(0,0,0,.25); transition:transform .2s ease;
  }
  .switch2 input:checked{ background:#c7d2fe; }
  .switch2 input:checked::after{ transform:translateX(18px); }
  .switch2 .switch-text{ font-weight:600; }
  .titlecard .controlbar,
  .titlecard .controlbar * .label,
  .titlecard .controlbar strong{ color:#000 !important; }

  /* Pill nav */
  .pillnav{
    position:sticky; top:0; z-index:10;
    background:rgba(247,248,251,.9); backdrop-filter:blur(6px);
    border-bottom:1px solid #e5e7eb; padding:8px 10px; margin:16px 0;
    border-radius:12px; box-shadow:0 6px 16px rgba(0,0,0,.05)
  }
  .pillnav a{
    display:inline-block; background:rgba(79,70,229,.1); color:var(--brand);
    padding:8px 12px; border-radius:999px; font-weight:600; font-size:13px; margin:6px 8px 6px 0;
    transition: background .15s ease, box-shadow .15s ease;
    text-decoration:none !important; /* remove underline */
  }
  .pillnav a:hover { background: rgba(79,70,229,.16); }
  .pillnav a:focus { outline:none; box-shadow:0 0 0 3px var(--ring); text-decoration:none; }

  /* Cards & grid */
  .grid{ display:grid; grid-template-columns:1fr 1fr; gap:18px }
  @media (max-width:860px){ .grid{ grid-template-columns:1fr } }
  .card{ background:var(--card); border-radius:14px; padding:18px; box-shadow:0 6px 20px rgba(0,0,0,.08) }
  .card h2{ margin:0 0 8px; display:flex; align-items:center; gap:10px }
  .logo{ width:28px; height:28px; border-radius:6px; object-fit:cover; border:1px solid #e5e7eb; background:#fff }

  /* MVP + highlights */
  .mvp{ display:flex; align-items:center; gap:12px; padding:12px; border:1px solid #e5e7eb; border-radius:12px; background:#fafbff; margin-bottom:10px }
  .good{ color:var(--good); font-weight:700 }
  .highlights{ display:grid; gap:8px; margin:8px 0 14px; }
  .chip{
    display:flex; align-items:center; gap:10px; background:#f8fafc;
    border:1px solid #e5e7eb; border-radius:12px; padding:10px 12px;
  }
  .chip .emoji{ font-size:18px } .chip .ttl{ font-weight:700 } .chip .sub{ color:#6b7280; font-size:12px }

  /* Standings */
  .table-wrap{ overflow-x:auto; -webkit-overflow-scrolling:touch; }
  table{ width:100%; border-collapse:separate; border-spacing:0 8px }
  th{ font-size:12px; text-transform:uppercase; letter-spacing:.04em; color:var(--muted); text-align:left; padding:0 10px }
  td{ background:#f9fafb; padding:10px; border-radius:8px }
  .row{
    display:grid; grid-template-columns:28px 1fr 60px 60px 80px 80px; gap:10px; align-items:center;
  }
  .mutedrow td{ background:transparent; padding:0 }
  .avatar{ width:28px; height:28px; border-radius:50%; background:#e5e7eb; display:inline-block; vertical-align:middle }
  .realname { font-size: 11px; color: #6b7280; line-height: 1.2; }

  /* Matchups card */
  .matchups{ margin-top:14px; border:1px solid #e5e7eb; background:#fbfdff; border-radius:12px; padding:12px; }
  .matchups h3{ margin:0 0 8px; font-size:16px; }
  .game{
    display:grid; grid-template-columns:1fr auto 1fr; align-items:center; gap:10px;
    background:#fff; border:1px solid #edf0f6; border-radius:12px; padding:10px 12px; margin:8px 0;
  }
  .team{ display:flex; align-items:center; gap:8px; min-width:0; }
  .name{ font-weight:600; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .score{ font-weight:700; }
  .sep{ color:#9aa3b2; font-weight:700; }
  .meta{ color:#6b7280; font-size:12px; margin-top:4px; }

  /* Anchor offset */
  section[id]{ scroll-margin-top: 90px; }

  /* Print */
  @media print{ .pillnav{ display:none } }

  /* Compact mode (Option B) */
  html.compact { --fs: 12px; }
  html.compact .wrap { padding: 0 12px; }
  html.compact .titlecard { padding: 18px; border-radius:16px; }
  html.compact .titlecard h1 { font-size: 26px; margin-bottom: 6px; }
  html.compact .badge { font-size: 11px; padding: 3px 8px; }
  html.compact .controlbar { gap: 10px; }
  html.compact .field { padding: 10px; }
  html.compact .pillnav { margin: 12px 0; padding: 6px 8px; }
  html.compact .card { padding: 14px; border-radius:12px; }
  html.compact .card h2 { font-size: 18px; gap: 8px; }
  html.compact .logo { width: 24px; height: 24px; }
  html.compact table { border-spacing: 0 6px; }
  html.compact td { padding: 8px; }
  html.compact .row { grid-template-columns: 22px 1fr 34px 34px 58px 58px; gap: 6px; }
  html.compact .avatar { width: 22px; height: 22px; }
  html.compact .mvp { padding: 10px; gap: 8px; }
  html.compact .game { padding: 8px 10px; }
</style>
</head>
<body>
<div class="wrap">
  <section class="titlecard">
    <h1>LWFL Dashboard <span class="badge" id="weekBadge">Week –</span></h1>
    <div class="muted">Standings & weekly MVPs (top winning score) for Alpha and Omega</div>

    <div class="controlbar">
      <div class="field">
        <div class="label">Week</div>
        <div class="input-row">
          <div class="select-wrap"><select id="weekSelect"></select></div>
          <span class="inline-note" id="currentWeekNote"></span>
        </div>
      </div>
      <div class="field">
        <div class="label">Live updates</div>
        <div class="input-row">
          <label class="switch2">
            <input type="checkbox" id="autoRefresh" checked />
            <span class="switch-text">Auto‑refresh</span>
          </label>
          <span class="inline-note" id="lastUpdated">Last updated: —</span>
          <button class="btn ghost" id="manualRefresh">Refresh now</button>
        </div>
      </div>
    </div>
  </section>

  <nav class="pillnav">
    <a href="#alpha">Alpha Standings</a>
    <a href="#omega">Omega Standings</a>
  </nav>

  <div class="grid">
    <!-- Alpha -->
    <section id="alpha" class="card">
      <h2><img class="logo" src="https://static.wixstatic.com/media/804338_f498e0a83a7e4c53955da943493ce4d6~mv2.png" alt=""> Alpha League</h2>
      <div class="mvp" id="alphaMvp"><span class="small">No results yet for this week.</span></div>
      <div class="highlights" id="alphaHighlights"></div>

      <div class="table-wrap" style="margin-top:12px">
        <table>
          <thead>
            <tr class="mutedrow"><td colspan="6">
              <div class="row"><span></span><span>Team</span><span>W</span><span>L</span><span>PF</span><span>PA</span></div>
            </td></tr>
          </thead>
          <tbody id="alphaTable"></tbody>
        </table>
      </div>

      <div class="matchups" id="alphaMatchups">
        <h3>This Week’s Matchups</h3>
        <div class="meta">Showing projections before kickoff; live/final scores once games begin.</div>
        <div id="alphaMatchupsBody"></div>
      </div>
    </section>

    <!-- Omega -->
    <section id="omega" class="card">
      <h2><img class="logo" src="https://static.wixstatic.com/media/804338_9571b11a8cf04cacb77b022d5c698610~mv2.png" alt=""> Omega League</h2>
      <div class="mvp" id="omegaMvp"><span class="small">No results yet for this week.</span></div>
      <div class="highlights" id="omegaHighlights"></div>

      <div class="table-wrap" style="margin-top:12px">
        <table>
          <thead>
            <tr class="mutedrow"><td colspan="6">
              <div class="row"><span></span><span>Team</span><span>W</span><span>L</span><span>PF</span><span>PA</span></div>
            </td></tr>
          </thead>
          <tbody id="omegaTable"></tbody>
        </table>
      </div>

      <div class="matchups" id="omegaMatchups">
        <h3>This Week’s Matchups</h3>
        <div class="meta">Showing projections before kickoff; live/final scores once games begin.</div>
        <div id="omegaMatchupsBody"></div>
      </div>
    </section>
  </div>
</div>

<script>
/*** Compact on phones (Option B) ***/
(function () {
  const isMobile =
    window.matchMedia('(max-width: 480px)').matches ||
    /iPhone|Android.*Mobile|Mobile Safari/i.test(navigator.userAgent);
  if (isMobile) document.documentElement.classList.add('compact');
})();

/*** League IDs ***/
const ALPHA_LEAGUE_ID = "1264173731110998016";
const OMEGA_LEAGUE_ID = "1267775313601908736";

/*** Owner real names (fill these in once) ***/
const OWNER_NAMES = {
  alpha: {
    "1267931238656638976": "Amber P.",
    "1267934216545370113": "Matt R.",
    "1267937395769094144": "Bill L.",
    "1267945277105389568": "CJ A.",
    "1267963622416461825": "Kaiya L.",
    "1267981254544855040": "Kelsey C.",
    "1268034589910114304": "Bob L.",
    "1268233388322467840": "Jim L.",
    "1268362055031726080": "Becky S.",
    "": "",
    // e.g. "987654321098765432": "CJ Anderson",
  },
  omega: {
    "1264215877419536384": "Andrew P.",
    "1265427643587637248": "Todd & Sam W.",
    "1267926580223553536": "Judy H.",
    "1267927818709245952": "Brad C.",
    "1267984032138809344": "Barb B.",
    "1267985221857316864": "Charis M.",
    "1268282169592135680": "Wes W.",
    "1268335873796100096": "Cindy W.",
    "1268400206718709760": "Warren M.",
    "1268621638769856512": "Tyler S.",
    // e.g. "123456789012345678": "Todd Wilson",
  }
};

/*** Utils ***/
const $ = sel => document.querySelector(sel);
const toPts2 = n => Number(n || 0).toFixed(2);
const fmtTime = d => d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
const sleep = ms => new Promise(r=>setTimeout(r,ms));
async function fetchJSON(url){ for (let i=0;i<2;i++){ const r=await fetch(url); if(r.ok)return r.json(); await sleep(200);} const r=await fetch(url); return r.json(); }
function groupBy(arr, keyFn){ const m=new Map(); for(const x of arr){ const k=keyFn(x); if(!m.has(k)) m.set(k,[]); m.get(k).push(x);} return m; }

/*** State (season, week, type) ***/
async function getState() {
  const s = await fetchJSON("https://api.sleeper.app/v1/state/nfl");
  return {
    week: s.display_week || s.week || s.leg || 1,
    season: s.season || new Date().getFullYear().toString(),
    season_type: s.season_type || "regular"
  };
}

/*** League info: roster_positions + roster_id -> players[] ***/
async function getLeagueInfo(leagueId) {
  const [league, rosters] = await Promise.all([
    fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}`),
    fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}/rosters`)
  ]);

  const rosterPositions = Array.isArray(league?.roster_positions) ? league.roster_positions : [];
  const rosterPlayers = {};
  for (const r of rosters) {
    rosterPlayers[r.roster_id] = Array.isArray(r.players) ? r.players : [];
  }
  return { rosterPositions, rosterPlayers };
}

/*** Count non-bench/IR starter slots from league roster positions ***/
function countStarterSlots(rosterPositions) {
  const ignore = new Set(["BN", "IR", "TAX"]);
  return rosterPositions.filter(p => !ignore.has(p)).length || 0;
}

/*** Map: player_id -> projected fantasy points (Half‑PPR)
 *  - Forces regular season
 *  - Requests only fantasy positions we care about
 *  - Reads multiple possible fields that Sleeper uses across seasons
 */
async function getProjectionsMap(season, week) {
  const POS = ["QB","RB","WR","TE","K","DEF"];
  const url =
    `https://api.sleeper.app/v1/projections/nfl/${season}/${week}` +
    `?season_type=regular` +
    POS.map(p => `&position[]=${encodeURIComponent(p)}`).join("");

  const items = await fetchJSON(url);

  const map = {};
  if (Array.isArray(items)) {
    for (const it of items) {
      const pid = it.player_id || it.player?.player_id || it.id;
      if (!pid) continue;

      const s = it.stats || it;
      const val =
        s.pts_half_ppr ??
        s.fpts_half_ppr ??
        s.fantasy_points_half_ppr ??
        s.fantasy_points_hppr ??
        s.pts_ppr ??
        s.fpts_ppr ??
        s.pts ?? s.fpts ??
        s.proj_fp ?? s.proj_points ?? 0;

      const num = Number(val);
      map[pid] = Number.isFinite(num) ? num : 0;
    }
  }

  // console diagnostic
  console.log("[projections] week", week, "items:", Array.isArray(items) ? items.length : "n/a",
              "mapped:", Object.keys(map).length);

  return map;
}

/*** Sum projections for a specific list of player_ids ***/
function sumProjectionsFor(players, projMap) {
  return Number(
    (players || []).reduce((acc, pid) => acc + (projMap[pid] || 0), 0).toFixed(2)
  );
}

/*** Fallback: if starters are empty, take the top N projected players on that roster ***/
function fallbackProjectedTotal(rosterId, projMap, rosterPlayersMap, starterSlotsCount) {
  const all = rosterPlayersMap[rosterId] || [];
  if (!all.length || starterSlotsCount <= 0) return 0;
  const scored = all.map(pid => projMap[pid] || 0);
  scored.sort((a,b) => b - a);
  const pick = scored.slice(0, starterSlotsCount);
  const sum = pick.reduce((a,b) => a + b, 0);
  return Number(sum.toFixed(2));
}

/*** Standings (returns rosterId->teamName map), renders owner real name under team name ***/
async function buildStandings(leagueId, tableSel, ownerNameMap) {
  const [users, rosters] = await Promise.all([
    fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}/users`),
    fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}/rosters`)
  ]);

  // Map user_id -> { teamName, avatar, displayName }
  const byUser = {};
  for (const u of users) {
    const teamName = (u.metadata && (u.metadata.team_name || u.metadata.team_name_update)) || u.display_name || u.username;
    byUser[u.user_id] = { teamName, avatar: u.avatar, displayName: u.display_name || u.username };
  }

  // Build rows
  const rows = rosters.map(r => {
    const u = byUser[r.owner_id] || {};
    const w = r.settings?.wins || 0;
    const l = r.settings?.losses || 0;
    const pf = Number(r.settings?.fpts || 0) + Number((r.settings?.fpts_decimal || 0)/100);
    const pa = Number(r.settings?.fpts_against || 0) + Number((r.settings?.fpts_against_decimal || 0)/100);
    // Prefer your manual mapping; fall back to Sleeper display name if not provided
    const realName = ownerNameMap?.[r.owner_id] || u.displayName || "";
    return {
      roster_id: r.roster_id,
      owner_id: r.owner_id,
      teamName: u.teamName || `Team ${r.roster_id}`,
      avatar: u.avatar,
      realName,
      w, l, pf, pa
    };
  });

  // Sort: W desc, PF desc, PA asc
  rows.sort((a,b)=> b.w - a.w || b.pf - a.pf || a.pa - b.pa);

  // Render
  const tbody = document.querySelector(tableSel);
  tbody.innerHTML = rows.map(r => `
    <tr><td colspan="6">
      <div class="row">
        <span><img class="avatar" src="${r.avatar ? `https://sleepercdn.com/avatars/thumbs/${r.avatar}` : ''}" alt=""></span>
        <span>
          <strong>${r.teamName}</strong>
          ${r.realName ? `<div class="realname">${r.realName}</div>` : ``}
        </span>
        <span>${r.w}</span>
        <span>${r.l}</span>
        <span>${r.pf.toFixed(2)}</span>
        <span>${r.pa.toFixed(2)}</span>
      </div>
    </td></tr>`).join("");

  // Return roster_id -> team name (used elsewhere)
  const byRoster = {};
  for (const r of rosters) {
    const u = byUser[r.owner_id] || {};
    byRoster[r.roster_id] = u.teamName || `Roster ${r.roster_id}`;
  }
  return byRoster;
}

/*** Weekly MVP (top winning score) ***/
async function findWeeklyTopWinner(leagueId, week) {
  const matchups = await fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}/matchups/${week}`);
  if (!Array.isArray(matchups) || matchups.length === 0) return null;
  const byMatchup = groupBy(matchups, m => m.matchup_id);
  let best = null;
  for (const games of byMatchup.values()) {
    let winner = games[0];
    for (const g of games) if ((g.points ?? 0) > (winner.points ?? 0)) winner = g;
    const wPoints = Number(winner.points || 0);
    if (!best || wPoints > best.points) best = { roster_id: winner.roster_id, points: wPoints };
  }
  return best;
}
function renderMvp(sel, mvp, rosterToTeam) {
  const el = $(sel);
  if (!mvp) { el.innerHTML = '<span class="small">No results yet for this week.</span>'; return; }
  const team = rosterToTeam[mvp.roster_id] || `Roster ${mvp.roster_id}`;
  el.innerHTML = `<div><div class="small">Week MVP (Top Winning Score)</div><div><strong>${team}</strong> <span class="good">+${toPts2(mvp.points)}</span></div></div>`;
}

/*** Weekly highlights: Closest & Blowout ***/
async function renderWeeklyHighlights(sel, leagueId, week, rosterMap){
  const el = $(sel); el.innerHTML = '';
  const matchups = await fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}/matchups/${week}`);
  if (!Array.isArray(matchups) || matchups.length === 0) {
    el.innerHTML = `<div class="chip"><span class="emoji">ℹ️</span><div><div class="ttl">No matchups yet</div><div class="sub">We’ll show highlights once games are final.</div></div></div>`;
    return;
  }
  const byMatchup = groupBy(matchups, m => m.matchup_id);
  let closest = null, blowout = null;
  for (const games of byMatchup.values()) {
    if (games.length < 2) continue;
    const sorted = [...games].sort((x,y)=> (y.points||0)-(x.points||0));
    const a = sorted[0], b = sorted[1];
    const aPts = Number(a.points||0), bPts = Number(b.points||0);
    if (aPts === 0 && bPts === 0) continue;
    const margin = Math.abs(aPts - bPts);
    const entry = { aName: rosterMap[a.roster_id] || `Roster ${a.roster_id}`, bName: rosterMap[b.roster_id] || `Roster ${b.roster_id}`, aPts, bPts, margin };
    if (!closest || margin < closest.margin) closest = entry;
    if (!blowout || margin > blowout.margin) blowout = entry;
  }
  if (!closest && !blowout){
    el.innerHTML = `<div class="chip"><span class="emoji">ℹ️</span><div><div class="ttl">No results yet</div><div class="sub">Check back as games conclude.</div></div></div>`;
    return;
  }
  if (closest){
    el.insertAdjacentHTML('beforeend', `<div class="chip"><span class="emoji">🎯</span><div><div class="ttl">Closest Game</div><div class="sub">${closest.aName} ${toPts2(closest.aPts)} — ${closest.bName} ${toPts2(closest.bPts)} (Δ ${toPts2(closest.margin)})</div></div></div>`);
  }
  if (blowout){
    el.insertAdjacentHTML('beforeend', `<div class="chip"><span class="emoji">💥</span><div><div class="ttl">Blowout of the Week</div><div class="sub">${blowout.aName} ${toPts2(blowout.aPts)} — ${blowout.bName} ${toPts2(blowout.bPts)} (Δ ${toPts2(blowout.margin)})</div></div></div>`);
  }
}

/*** Matchups (projections before kickoff; live/final once scoring) ***/
async function renderMatchups(leagueId, week, rosterMap, containerSel){
  const body = $(containerSel);
  body.innerHTML = '';

  const [{season}, matchups, leagueInfo] = await Promise.all([
    getState(),
    fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}/matchups/${week}`),
    getLeagueInfo(leagueId)
  ]);

  if (!Array.isArray(matchups) || matchups.length === 0){
    body.innerHTML = `<div class="meta">No matchups found for this week yet.</div>`;
    return;
  }

  const { rosterPositions, rosterPlayers } = leagueInfo;
  const starterSlotsCount = countStarterSlots(rosterPositions);

  const byMatchup = groupBy(matchups, m => m.matchup_id);

  // Detect if any side has non‑zero points
  let anyScoring = false;
  for (const ms of byMatchup.values()){
    for (const m of ms){ if (Number(m.points||0) > 0){ anyScoring = true; break; } }
    if (anyScoring) break;
  }

  // Only fetch projections pre‑kickoff
  const projMap = anyScoring ? null : await getProjectionsMap(season, week);
  const projAvailable = !!projMap && Object.values(projMap).some(v => Number(v) > 0.01);
  if (!anyScoring && !projAvailable) {
    console.warn("[projections] none > 0 for week", week, "— showing dashes until Sleeper publishes.");
  }

  for (const games of byMatchup.values()){
    if (games.length < 2) continue;
    const a = games[0], b = games[1];

    const aName = rosterMap[a.roster_id] || `Roster ${a.roster_id}`;
    const bName = rosterMap[b.roster_id] || `Roster ${b.roster_id}`;

    let midLabel = 'vs';
    let leftScore = 0, rightScore = 0;

    if (!anyScoring && projAvailable) {
      const aStarters = Array.isArray(a.starters) ? a.starters.filter(Boolean) : [];
      const bStarters = Array.isArray(b.starters) ? b.starters.filter(Boolean) : [];

      if (aStarters.length) {
        leftScore = sumProjectionsFor(aStarters, projMap);
      } else {
        leftScore = fallbackProjectedTotal(a.roster_id, projMap, rosterPlayers, starterSlotsCount);
      }

      if (bStarters.length) {
        rightScore = sumProjectionsFor(bStarters, projMap);
      } else {
        rightScore = fallbackProjectedTotal(b.roster_id, projMap, rosterPlayers, starterSlotsCount);
      }

      midLabel = 'proj';
    } else {
      leftScore  = toPts2(a.points);
      rightScore = toPts2(b.points);
      midLabel = (Number(a.points||0) + Number(b.points||0)) > 0 ? 'live' : 'vs';
    }

    body.insertAdjacentHTML('beforeend', `
      <div class="game">
        <div class="team"><span class="name">${aName}</span></div>
        <div class="sep">${midLabel}</div>
        <div class="team" style="justify-content:flex-end"><span class="name" style="text-align:right">${bName}</span></div>
        <div class="team"><span class="score">${toPts2(leftScore)}</span></div>
        <div></div>
        <div class="team" style="justify-content:flex-end"><span class="score">${toPts2(rightScore)}</span></div>
      </div>
    `);
  }
}

/*** Populate week selector ***/
function populateWeekSelect(currentWeek){
  const sel = $("#weekSelect"); sel.innerHTML = "";
  for (let w=1; w<=18; w++){
    const opt = document.createElement("option");
    opt.value = String(w);
    opt.textContent = (w === currentWeek) ? `Week ${w} (current)` : `Week ${w}`;
    sel.appendChild(opt);
  }
  sel.value = String(currentWeek);
  $("#weekBadge").textContent = `Week ${currentWeek}`;
  $("#currentWeekNote").textContent = `Current week: ${currentWeek}`;
}

/*** One‑time helper: print user_id cheat sheet to console for mapping ***/
async function logOwnerIdCheatSheet(leagueId, label) {
  const users = await fetchJSON(`https://api.sleeper.app/v1/league/${leagueId}/users`);
  console.group(`Owner ID Cheat Sheet – ${label}`);
  for (const u of users) {
    const teamName = (u.metadata && (u.metadata.team_name || u.metadata.team_name_update)) || u.display_name || u.username;
    console.log(`${teamName} :: ${u.display_name || u.username} :: user_id=${u.user_id}`);
  }
  console.groupEnd();
}

/*** Load all for a given week ***/
async function loadWeek(week){
  const [alphaMap, alphaMvp] = await Promise.all([
    buildStandings(ALPHA_LEAGUE_ID, "#alphaTable", OWNER_NAMES.alpha),
    findWeeklyTopWinner(ALPHA_LEAGUE_ID, week)
  ]);
  renderMvp("#alphaMvp", alphaMvp, alphaMap);

  const [omegaMap, omegaMvp] = await Promise.all([
    buildStandings(OMEGA_LEAGUE_ID, "#omegaTable", OWNER_NAMES.omega),
    findWeeklyTopWinner(OMEGA_LEAGUE_ID, week)
  ]);
  renderMvp("#omegaMvp", omegaMvp, omegaMap);

  await Promise.all([
    renderWeeklyHighlights("#alphaHighlights", ALPHA_LEAGUE_ID, week, alphaMap),
    renderWeeklyHighlights("#omegaHighlights", OMEGA_LEAGUE_ID, week, omegaMap),
    renderMatchups(ALPHA_LEAGUE_ID, week, alphaMap, "#alphaMatchupsBody"),
    renderMatchups(OMEGA_LEAGUE_ID, week, omegaMap, "#omegaMatchupsBody"),
  ]);

  $("#lastUpdated").textContent = `Last updated: ${fmtTime(new Date())}`;
}

/*** Main ***/
(async function(){
  const { week: currentWeek } = await getState();
  populateWeekSelect(currentWeek);
  await loadWeek(currentWeek);

  // One‑time helper: open DevTools → Console to copy user_ids, then fill OWNER_NAMES above.
  // Comment these two lines out after you’ve copied the IDs.
  logOwnerIdCheatSheet(ALPHA_LEAGUE_ID, "Alpha");
  logOwnerIdCheatSheet(OMEGA_LEAGUE_ID, "Omega");

  $("#weekSelect").addEventListener("change", async (e)=>{
    const selWeek = Number(e.target.value);
    $("#weekBadge").textContent = `Week ${selWeek}`;
    await loadWeek(selWeek);
  });

  let timer = setInterval(async ()=>{
    const selWeek = Number($("#weekSelect").value);
    await loadWeek(selWeek);
  }, 120000);

  $("#autoRefresh").addEventListener("change", (e)=>{
    if (e.target.checked) {
      if (!timer) timer = setInterval(async ()=>{
        const selWeek = Number($("#weekSelect").value);
        await loadWeek(selWeek);
      }, 120000);
    } else {
      clearInterval(timer); timer = null;
    }
  });

  $("#manualRefresh").addEventListener("click", async ()=>{
    const selWeek = Number($("#weekSelect").value);
    await loadWeek(selWeek);
  });
})();
</script>
</body>
</html>
